interface ColumnInfo {
  name: string;
  type: string;
  notNull?: boolean;
  defaultValue?: any;
  primaryKey?: boolean;
}

interface SchemaFilterResult {
  filteredData: Record<string, any>;
  missingFields: string[];
  populatedFields: string[];
}

/**
 * Enhanced data filtering with intelligent default value population
 */
export class SchemaDataFilter {
  
  /**
   * Get appropriate default value based on column type and constraints
   */
  private static getDefaultValueForColumn(column: ColumnInfo): any {
    // If column has explicit default, use it (unless it's a function/expression)
    if (column.defaultValue !== undefined && column.defaultValue !== null) {
      const defaultStr = String(column.defaultValue).toUpperCase();
      
      // Skip function defaults like CURRENT_TIMESTAMP, randomblob(), etc.
      if (!defaultStr.includes('(') && 
          !['CURRENT_TIMESTAMP', 'CURRENT_DATE', 'CURRENT_TIME'].includes(defaultStr)) {
        return column.defaultValue;
      }
    }
    console.log("column:", column)
    const type = column.type?.toUpperCase() ?? '';
    
    // Handle primary keys - don't set defaults as they're usually auto-generated
    if (column.primaryKey) {
      return undefined;
    }

    // Type-based defaults
    switch (type) {
      case 'TEXT':
      case 'VARCHAR':
      case 'STRING':
        return '';
      
      case 'INTEGER':
      case 'INT':
      case 'BIGINT':
      case 'SMALLINT':
        return 0;
      
      case 'REAL':
      case 'FLOAT':
      case 'DOUBLE':
      case 'DECIMAL':
      case 'NUMERIC':
        return 0.0;
      
      case 'BOOLEAN':
      case 'BIT':
        return false;
      
      case 'DATE':
        // Return empty string for dates to avoid invalid date issues
        return '';
      
      case 'DATETIME':
      case 'TIMESTAMP':
        // Return empty string for timestamps to avoid invalid date issues
        return '';
      
      case 'BLOB':
      case 'BINARY':
        return new Uint8Array(0);
      
      case 'JSON':
      case 'JSONB':
        return {};
      
      default:
        // For unknown types, return empty string as safest default
        return '';
    }
  }

  /**
   * Enhanced filtering that populates missing fields with appropriate defaults
   */
  static async filterAndPopulateData(
    data: Record<string, any>, 
    getSchemaFn: () => Promise<{ success: boolean; data?: { columns: ColumnInfo[] } }>,
    options: {
      skipPrimaryKey?: boolean;
      skipAutoGenerated?: boolean;
      skipTimestamps?: boolean;
      customDefaults?: Record<string, any>;
      requiredOnly?: boolean;
    } = {}
  ): Promise<SchemaFilterResult> {
    
    const {
      skipPrimaryKey = true,
      skipAutoGenerated = true,
      skipTimestamps = true,
      customDefaults = {},
      requiredOnly = false
    } = options;

    const result: SchemaFilterResult = {
      filteredData: {},
      missingFields: [],
      populatedFields: []
    };

    try {
      const schemaResult = await getSchemaFn();
      console.log("schemaResult", schemaResult.data);
      
      if (!schemaResult.success || !schemaResult.data?.columns) {
        console.warn('Could not retrieve schema. Returning original data.');
        result.filteredData = { ...data };
        return result;
      }

      const columns = schemaResult.data.columns;
      const validColumns = new Set(columns.map(col => col.name));
      
      // Auto-generated field patterns
      const autoGeneratedFields = new Set([
        'id'
      ]);
      
      // First pass: copy existing valid data
      for (const [key, value] of Object.entries(data)) {
        if (validColumns.has(key) && value !== undefined) {
          result.filteredData[key] = value;
        }
      }

      // Second pass: populate missing fields
      for (const column of columns) {
        const fieldName = column.name;
        
        // Skip if already present in data
        if (result.filteredData.hasOwnProperty(fieldName)) {
          continue;
        }

        // Skip primary keys if requested
        if (skipPrimaryKey && column.primaryKey) {
          continue;
        }

        // Skip auto-generated fields if requested
        if (skipAutoGenerated && autoGeneratedFields.has(fieldName)) {
          continue;
        }

        // Skip timestamp fields if requested
        if (skipTimestamps && fieldName.match(/_at$/)) {
          continue;
        }

        // If requiredOnly mode, only populate required (NOT NULL) fields
        if (requiredOnly && !column.notNull) {
          result.missingFields.push(fieldName);
          continue;
        }

        // Check for custom default first
        let defaultValue;
        if (customDefaults.hasOwnProperty(fieldName)) {
          defaultValue = customDefaults[fieldName];
        } else {
          defaultValue = this.getDefaultValueForColumn(column);
        }

        // Only set if we have a meaningful default
        if (defaultValue !== undefined) {
          result.filteredData[fieldName] = defaultValue;
          result.populatedFields.push(fieldName);
        } else {
          result.missingFields.push(fieldName);
        }
      }

      return result;

    } catch (error: any) {
      console.error('Error in filterAndPopulateData:', error);
      result.filteredData = { ...data };
      return result;
    }
  }

  /**
   * Simpler version that just filters without population
   */
  static async filterBySchema(
    data: Record<string, any>, 
    getSchemaFn: () => Promise<{ success: boolean; data?: { columns: ColumnInfo[] } }>
  ): Promise<Record<string, any>> {
    
    const result = await this.filterAndPopulateData(data, getSchemaFn, { 
      requiredOnly: true // Only populate required fields
    });
    return result.filteredData;
  }

  /**
   * Version that populates all missing fields with defaults
   */
  static async filterAndFillDefaults(
    data: Record<string, any>, 
    getSchemaFn: () => Promise<{ success: boolean; data?: { columns: ColumnInfo[] } }>,
    customDefaults: Record<string, any> = {}
  ): Promise<Record<string, any>> {
    
    const result = await this.filterAndPopulateData(data, getSchemaFn, { 
      customDefaults,
      skipPrimaryKey: true,
      skipAutoGenerated: true,
      skipTimestamps: false, // Include timestamps with defaults
      requiredOnly: false    // Fill all fields
    });
    return result.filteredData;
  }
}
export type { SchemaFilterResult,ColumnInfo }